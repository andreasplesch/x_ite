<section>
<div>
<h1>Script Node Authoring Interface</h1>
This is a referende for ECMAScript, a scripting language for X3D Script nodes. ECMAScript grew out of the need for a lightweight script language in X3D. It is a subset of the JavaScript language, with X3D data types supported as JavaScript built-in objects.

[mwm-aal-display]

Because of this it has many advantages over other script languages (such as Java):
<ul>
 	<li>Scripts can be included in source form, inline rather than in a separate URL.</li>
 	<li>All X3D data types are supported directly. Some, like the vector types have built in methods (such as cross product and normalize) to simplify working with them.</li>
 	<li>Receiving input events is handled with separate functions to ease development and to speed processing.</li>
 	<li>Sending output events is done with simple assignment.</li>
 	<li>Scalar data (SFTime, SFInt32, SFFloat, SFBool) can be used directly in expressions. The JavaScript number object converts directly to any of the four scalar data types. For instance, you can add 3 seconds to an SFTime value with <em>a = time + 3;</em></li>
 	<li>Constructors are available for most data types to ease creation and conversion of data.</li>
 	<li>A full set of JavaScript compatible math, date and string objects is available. The full set of JavaScript string methods and properties are available. Scalar values automatically convert to strings when concatenated. This makes construction of URL's and X3D strings (for use in createX3DFromString) easy.</li>
</ul>
</div>
</section><section>
<div>
<h1>Objects and Variables</h1>
Data in ECMAScript is represented as objects. The object types correspond to the X3D field types. A variable contains an instance of an object, and can be predefined (appearing in the Script node) or defined locally.
<h2>Values, Names and Literals</h2>
A ECMAScript variable holds an instance of an object. If a name is defined as a field or output field of the Script node containing the script then there is a variable with that same name available globally to the script. The type of this variable is always the type of the field or output field. Assignment to this variable converts the expression to its type or generates a run-time error if a conversion is not possible.

The names specified in the declaration of a function (the data value and the timestamp) are local to the function in which they are declared. It is a run-time error to assign to these variables.

Local variables can be created simply by assigning to a name that does not yet exist. Assigning to such a variable causes it take the type of the expression, so these local variables always have the type of the last assignment. Local variables are scoped by the block in which they were first introduced. Once that block is exited, the variable ceases to exist. Variables corresponding to outputOnly fields or initializeOnly fields of the Script node are global in scope.

Variable names must start with the a lowercase character ('a' through 'z'), an uppercase character ('A' through 'Z'), or an underscore ('_'). Subsequent characters can be any of these or a digit ('0' through '9'). Variable names are case sensitive.

Numeric, boolean, and string literals are allowed. Numeric literals can be integers in decimal (417), hex (0x5C), or octal (0177) notation. They can also be floating point numbers in fixed (1.76) or exponential (2.7e-12) notation. All numeric literals are of the number type. Boolean literals can be 'true' or 'false' and have the boolean type. String literals can be any sequence of UTF8 characters enclosed in single quotes ('), and have the type String. Special (non-printable) characters can be included in a string using the following escape sequences:
<table>
<thead>
<tr>
<th>Sequence</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>\b</td>
<td>backspace</td>
</tr>
<tr>
<td>\f</td>
<td>form feed</td>
</tr>
<tr>
<td>\n</td>
<td>new line</td>
</tr>
<tr>
<td>\r</td>
<td>carriage return</td>
</tr>
<tr>
<td>\t</td>
<td>tab</td>
</tr>
<tr>
<td>\'</td>
<td>single quote (apostrophe)</td>
</tr>
<tr>
<td>\"</td>
<td>double quote</td>
</tr>
<tr>
<td>\\</td>
<td>backslash</td>
</tr>
</tbody>
</table>
Here are some examples:
<pre class="lang:default decode:true">Script {
  initializeOnly  SFFloat aField  0
  initializeOnly  SFVec3f aVector 0 0 0
  outputOnly      SFInt32 anOutputField
  inputOnly       SFBool  event

  url "ecmascript:

function event (value, time)
{
  var a = false;

  if (aField == 1.5)
  {
    a = true;      // 'a' contains a boolean
  }

  if (a)
  {
    value = 5;  // ERROR, can't assign to function parameter!
  }

  aField = anOutputField; // SFInt32 converted to SFFloat

  var b = aField;         // 'b' contains a number

  b      = anOutputField;  // 'b' now contains a different number
  aField = aVector;        // ERROR, can't assign SFVec3f to SFFloat!
  var s = 'Two\nLines';    // 's' contains a String
     
}"
}
</pre>
<h2>Objects and Fields</h2>
For each field and outputOnly fields in the Script node containing the script there is a corresponding global variable with the same name. Field variables are persistant; they keep their last stored value across function calls. Local variables, on the other hand, are destroyed on exit from the block in which they were defined. Local variables defined in the outermost block of a function are destroyed when the function exits so they do not persist across function calls.

OutputOnly fields are very similar to field variables in that their values persist across function calls. But when an assignment is made to an outputOnly fields an event is generated.

Every object has a set of <em>properties</em> and <em>methods</em>. Properties are names on the object that can be selected (using the '.' operator) then used in an expression or as the target of an expression. Methods are names on the object that can be called (using the function call operator) to perform some operation on the object. For example:
<pre class="">function someFunction ()
{
  a = new SFColor (0.5, 0.5, 0.5);
  b = a .r;                         // 'b' contains 0.5
  a .setHSV (0.1, 0.1, 0.1);        // 'a' now contains new properties
}
</pre>
The value <em>a.r</em> selects the property which corresponds to the red component of the color. The value <em>a .setHSV ()</em> selects the method which sets the color in HSV space.
<h2>Object Construction</h2>
For each object type there is a corresponding constructor. Constructors typically take a flexible set of parameters to allow construction of objects with any initial value. MF objects are essentially arrays so they always take 0 or more parameters of the corresponding SF object type. A value of a given data type is created using the <em>new</em> keyword with the data type name. For instance:
<pre class="">a = new SFVec3f (0, 1, 0);   // 'a' has a SFVec3f containing 0, 1, 0 b = new MFFloat (1, 2, 3, 4) // 'b' has a MFFloat containing 4 floats
</pre>
<h2>Data Conversion</h2>
Combining objects of different types in a single expression or assignment statement will often perform implicit type conversion. Rules for this conversion are described in the following table:
<table>
<thead>
<tr>
<th>Type</th>
<th>Rules</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>String</strong></td>
<td>
<ul>
 	<li>Combining a String with any number or boolean type produces a String</li>
 	<li>Use parseInt () or parseFloat to convert a String to a number</li>
</ul>
</td>
</tr>
<tr>
<td><strong>Number and boolean types</strong></td>
<td>
<ul>
 	<li>Assigning a number or boolean expression to a fixed variable (initializeOnly field, outputOnly fields, or  inputOutput fields) of scalar type (SFBool, SFDouble, SFFloat, SFInt32, SFTime) converts to the type of the fixed variable</li>
</ul>
</td>
</tr>
<tr>
<td><strong>Vector types</strong>
SFColor
SFColorRGBA
SFMatrix3d
SFMatrix3f
SFMatrix4d
SFMatrix4f SFRotation
SFVec2d
SFVec2f
SFVec3d
SFVec3f
SFVec3d
SFVec4f</td>
<td>
<ul>
 	<li>Only combine with like types</li>
 	<li>Dereference (foo[1]) produces a value of number type</li>
</ul>
</td>
</tr>
<tr>
<td>SFImage</td>
<td>
<ul>
 	<li>Assignment ('=') and selection ('.') are the only allowed operations</li>
 	<li>Can only assign SFImage type</li>
</ul>
</td>
</tr>
<tr>
<td>SFNode</td>
<td>
<ul>
 	<li>Assignment ('=') and selection ('.') are the only allowed operations</li>
 	<li>Can only assign SFNode type</li>
</ul>
</td>
</tr>
<tr>
<td><strong>MF types
</strong>MFBool<strong>
</strong>MFColor
MFColorRGBA
MFDouble
MFFloat
MFImage
MFInt32
MFMatrix3d
MFMatrix3f
MFMatrix4d
MFMatrix4f
MFNode
MFRotation
MFString
MFTime
MFVec2d
MFVec2f
MFVec3d
MFVec3f
MFVec4d
MFVec4f</td>
<td>
<ul>
 	<li>Only combine with like types</li>
 	<li>Dereference (myArray[3]) produces the corresponding SF type.</li>
 	<li>Dereferenced SF types follow same rules as normal SF types.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<h2>MF Objects</h2>
Most SF objects in ECMAScript have a corresponding MF object. An MFObject is essentially an array of objects, with each element of the array having the type of the corresponding SF object. All MF objects have a <em>length</em> property which returns or sets the number of elements in the MF object. Array indexes start at 0. If <em>vecArray</em> is an MFVec3f object then <em>vecArray[0]</em> is the first SFVec3f object in the array.

Dereferencing an MF object creates a new object of the corresponding SF object type with the contents of the dereferenced element. Assigning an SF object to a dereferenced MF object (which must be of the corresponding type) copies the contents of the SF object into the dereferenced element.

</div>
</section><section>
<div>
<h1>Supported Protocol in the Script Node's <em>url</em> Field</h1>
The <em>url</em> field of the Script node may contain a URL that references ECMAScript code:
<pre class="">Script { url "http://foo.com/myScript.js" }</pre>
The <em>ecmascript:</em> protocol allows the script to be placed inline as follows:
<pre class="">Script {
  url "ecmascript:

function foo () {
  ...
}
  "
}</pre>
The <em>url</em> field may contain multiple URL's and thus reference a remote file or in-line code:
<pre class="">Script {
  url [
    "http://foo.com/myScript.js",
    "ecmascript: function foo () { ... }"
  ]
}</pre>
<h2>File Extension</h2>
The file extension for ECMAScript source code is <strong>.js</strong>.
<h2>MIME Type</h2>
The MIME type for ECMAScript source code is defined as follows:
<pre class="">application/x-javascript</pre>
</div>
</section><section>
<div>
<h1>InputOnly Field Handling</h1>
Events sent to the Script node are passed to the corresponding ECMAScript function in the script. It is necessary to specify the script in the <em>url </em>field of the Script node. The function's name is the same as the inputOnly field and is passed two arguments, the event value and its timestamp. If there isn't a corresponding ECMAScript function in the script, the browser's behavior is undefined.

For example, the following Script node has one inputOnly field whose name is
<em>start</em>:
<pre class="">Script {
  inputOnly SFBool start
  url "ecmascript:

function start (value, time)
{
 ...
}
  "
}</pre>
In the above example, when the <em>start</em> inputOnly field is sent the start () function is executed.
<h2>Parameter Passing and the InputOnly Field Function</h2>
When a Script node receives an inputOnly field, a corresponding method in the file specified in the <em>url</em> field of the Script node is called, which has two arguments. The value of the inputOnly field is passed as the first argument and timestamp of the inputOnly field is passed as the second argument. The type of the value is the same as the type of the inputOnly field and the type of the timestamp is <strong>SFTime</strong>.
<h2>initialize () Method</h2>
Authors may define a function named <em>initialize</em> which is called when the corresponding Script node has been loaded and before any events are processed. This can be used to prepare for processing before events are received, such as constructing geometry or initializing external mechanisms.

The <em>initialize</em> function takes no parameters. Events generated from it are given the timestamp of when the Script node was loaded.
<h2>prepareEvents () Method</h2>
Authors may define a prepareEvents () method that is called only once per frame. prepareEvents () is called before any ROUTE processing and allows a Script to collect any asynchronously generated data, such as input from a network queue or the results of calling field listeners, and generate events to be handled by the browser's normal event processing sequence as if it were a built-in sensor node.
<h2>eventsProcessed () Method</h2>
Authors may define a function named <em>eventsProcessed</em> which will be called after some set of events has been received. Some implementations will call this function after the return from each inputOnly field function, while others will call it only after processing a number of inputOnly field functions. In the latter case an author can improve performance by placing lengthy processing algorithms which do not need to be executed for every event received into the
<em>eventsProcessed</em> function.

<strong>Example:</strong>

The author needs to compute a complex inverse kinematics operation at each time step of an animation sequence. The sequence is single-stepped using a TouchSensor and button geometry. Normally the author would have an inputOnly field function execute whenever the button is pressed. This function would increment the time step then run the inverse kinematics algorithm. But this would execute the complex algorithm at every button press and the user could easily get ahead of the algorithm by clicking on the button rapidly. To solve this the inputOnly field function can be changed to simply increment the time step and the IK algorithm can be moved to an eventsProcessed function. In an efficient implementation the clicks would be queued. When the user clicks quickly the time step would be incremented once for each button click but the complex algorithm will be executed only once. This way the animation sequence will keep up with the user.

The <em>eventsProcessed</em> function takes no parameters. Events generated from it are given the timestamp of the last event processed.
<h2>shutdown () Method</h2>
Authors may define a function named <em>shutdown</em> which is called when the corresponding Script node is deleted or the world containing the Script node is unloaded or replaced by another world. This can be used to send events informing external mechanisms that the Script node is being deleted so they can clean up files, etc.

The <em>shutdown</em> function takes no parameters. Events generated from it are given the timestamp of when the Script node was deleted.

</div>
</section><section>
<div>
<h1>Accessing Fields</h1>
The initializeOnly fields, inputOnly fields, outputOnly fields, and inputOutput fields of a Script node are accessible from its ECMAScript functions. As in all other nodes the fields are accessible only within the Script. The Script's inputOnly fields can be routed to and its outputOnly fields can be routed from. Another Script node with a pointer to this node can access its inputOnly fields and outputOnly fields just like any other node.
<h2>Accessing InitializeOnly and OutputOnly Fields of the Script</h2>
Fields defined in the Script node are available to the script by using its name. It's value can be read or written. This value is persistent across function calls. outputOnly fields defined in the script node can also be read. The value is the last value sent.
<h2>Accessing InitializeOnly Fields and OutputOnly Fields of Other Nodes</h2>
The script can access any inputOutput field, inputOnly fields or outputOnly fields of any node to which it has a pointer:
<pre class="">DEF SomeNode Transform { }

Script {
  inputOnly      SFVec3f pos
  initializeOnly SFNode  node USE SomeNode
  url "ecmascript:
...

function pos (value)
{
  node.set_translation = value;
}
  "
  directOutput TRUE
}</pre>
This sends a set_translation inputOnly field to the Transform node. An inputOnly field on a passed node can appear only on the left side of the assignment. An outputOnly fields or inputOutput field in the passed node can appear only on the right side, which reads the last value sent out. Fields in the passed node cannot be accessed, but inputOutput fields can either send an event to the »set_...« inputOnly field, or read the current value of the »..._changed« outputOnly fields. This follows the routing model of the rest of X3D.
<h2>Sending OutputOnly Fields</h2>
Assigning to an outputOnly fields or inputOutput field sends that event at the completion of the currently executing function. This implies that assigning to the outputOnly field or inputOutput field multiple times during one execution of the function still only sends one event and that event is the last value assigned.

</div>
</section><section>
<div>
<h1><strong>Object and Function Definitions</strong></h1>
There are a fixed set of objects in ECMAScript, each of which have a fixed set of properties (i.e. values) and methods (i.e. functions). For all object types except Math, there are functions to create an instance of the object. The supported set of objects are:
<h2>parseInt and parseFloat Functions</h2>
These 2 functions are provided to convert a String value to an SFInt32 or SFFloat value.
<ul>
 	<li><strong>parseInt (s, [radix])</strong>
<ul>
 	<li>Converts the passed String, 's', to an integer valued number, using the optional passed numeric 'radix' as the base. If the radix is omitted base 10 is assumed. Numbers can be in decimal (123), hexadecimal (0x5C) or octal (0177) notation and may be preceeded by a minus sign ('-'). Conversion stops at the first unrecognized character. If the string begins with an unrecognized character, 0 is returned.</li>
</ul>
</li>
 	<li><strong>parseFloat (s)</strong>
<ul>
 	<li>Converts the passed String, 's', to a floating point valued number. Numbers can be in fixed (1.23) or exponential (12E3) notation and both the mantissa and exponent may be preceeded by a minus sign ('-'). Conversion stops at the first unrecognized character. If the string begins with an unrecognized character, 0 is returned.</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>Browser Object</h1>
This section lists the methods available in the <em>browser</em> object, which allows scripts to get and set browser information. For descriptions of the methods.
<h2>Instance Creation Method(s)</h2>
None. One global instance of the object is available. The name of the instance is Browser.
<h2>Properties</h2>
<ul>
 	<li>name
<ul>
 	<li>A browser-implementation specific string describing the browser</li>
</ul>
</li>
 	<li>version
<ul>
 	<li>A browser-implementation specific string describing the browser version.</li>
</ul>
</li>
 	<li>currentSpeed
<ul>
 	<li>If this is not supported, the string "0.0" is returned</li>
</ul>
</li>
 	<li>currentFrameRate
<ul>
 	<li>If this is not supported, the string "0.0" is returned</li>
</ul>
</li>
 	<li>description
<ul>
 	<li>A user-defined string which can be read and written.</li>
</ul>
</li>
 	<li>supportedComponents
<ul>
 	<li>The property value cannot be changed, but the properties of the ComponentInfoArray can be.</li>
</ul>
</li>
 	<li>supportedProfiles
<ul>
 	<li>The property value cannot be changed, but the properties of the ProfileInfoArray can be.</li>
</ul>
</li>
 	<li>currentScene
<ul>
 	<li>The real type of this class is dependent on whether the user code is inside a prototype instance or not. If the user code is inside a prototype instance the property shall represent a X3DExecutionContenxt otherwise it shall represent a X3DScene.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>void <strong>replaceWorld</strong>(X3DScene)
<ul>
 	<li>Replace the current world with this new scene that has been loaded or constructed from somewhere.</li>
</ul>
</li>
 	<li>X3DScene <strong>createX3DFromString</strong>(String x3dSyntax)
<ul>
 	<li>The string may be any valid X3D content in any language supported by the browser implementation. If the browser does not support the content encoding the appropriate exception shall be thrown.</li>
</ul>
</li>
 	<li>void <strong>createX3DFromURL</strong>(MFString url, Node node, String event)
<ul>
 	<li>Parse the passed URL into a X3D scene. When complete send the passed event to the passed node. The event is a string with the name of an MFNode inputOnly field the passed node.</li>
</ul>
</li>
 	<li>void <strong>loadURL</strong>(MFString url, MFString parameter)
<ul>
 	<li>Load the passed URL, using the passed parameter string to possibly redirect it to another frame. If the destination is the frame containing the current scene, this method may never return.</li>
</ul>
</li>
 	<li>void <strong>setBrowserOption</strong>(String name, Object value)
<ul>
 	<li>Sets a browser option with the corresponding name to the given value.</li>
</ul>
</li>
 	<li>String <strong>getBrowserOption</strong>(String name)
<ul>
 	<li>Returns a browser option with the corresponding name.</li>
</ul>
</li>
 	<li>String <strong>getRenderingProperty</strong>(String name)
<ul>
 	<li>Returns a rendering property with the corresponding name.</li>
</ul>
</li>
 	<li>void <strong>print</strong>(Object)
<ul>
 	<li>Prints the object to the browser's console without a newline character. Successive calls to this function append the descriptions on the same line. The output is the implicit call to the object's toString () function.</li>
</ul>
</li>
 	<li>void <strong>println</strong>(Object)
<ul>
 	<li>Prints the object to the browser's console, inserting a newline character after the output. Successive calls to this function will result in each output presented on separate lines. The output is the implicit call to the object's toString () function.</li>
</ul>
</li>
</ul>
<h2>More Methods</h2>
<ul>
 	<li>void <strong>addRoute</strong>(SFNode sourceNode, String sourceField, SFNode destinationNode, String destinationField)
<ul>
 	<li>Add a route from the passed sourceField to the passed destinationField.</li>
</ul>
</li>
 	<li>void <strong>deleteRoute</strong>(SFNode sourceNode, String sourceField, SFNode destinationNode, String destinationField)
<ul>
 	<li>Remove the route between the passed sourceField and passed destinationField, if one exists.</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>Math Object</h1>
The Math object is unique in ECMAScript in that there is exactly one globally available instance of the object, named Math. Properties can be accessed using the syntax <em>Math.&lt;property-name&gt;</em>. Methods can be invoked using the syntax <em>Math.&lt;function-name&gt; ( &lt;argument-list&gt; )</em>.
<h2>Instance Creation Method(s)</h2>
None. One global instance of the object is available. The name of the instance is Math.
<h2>Properties</h2>
<ul>
 	<li>E
<ul>
 	<li>Euler's constant, <em>e</em>, approximately 2.718</li>
</ul>
</li>
 	<li>LN10
<ul>
 	<li>Natural logarithm of 10, approximately 2.302</li>
</ul>
</li>
 	<li>LN2
<ul>
 	<li>Natural logarithm of 2, approximately 0.693</li>
</ul>
</li>
 	<li>PI
<ul>
 	<li>Ratio of the circumference of a circle to its diameter, approximately 3.1415</li>
</ul>
</li>
 	<li>SQRT1_2
<ul>
 	<li>square root of ½, approximately 0.707</li>
</ul>
</li>
 	<li>SQRT2
<ul>
 	<li>square root of 2, approximately 1.414</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
Note <em>number</em>, <em>number1</em>, <em>number2</em>, <em>base</em>, and <em>exponent</em> indicate any expression with a scalar value.
<ul>
 	<li>abs (<em>number</em>)
<ul>
 	<li>Returns the absolute value of <em>number</em></li>
</ul>
</li>
 	<li>acos (<em>number</em>)
<ul>
 	<li>Returns the arc cosine (in radians) of <em>number</em></li>
</ul>
</li>
 	<li>asin (<em>number</em>)
<ul>
 	<li>Returns the arc sine (in radians) of <em>number</em></li>
</ul>
</li>
 	<li>atan (<em>number</em>)
<ul>
 	<li>Returns the arc tangent (in radians) of <em>number</em></li>
</ul>
</li>
 	<li>ceil (<em>number</em>)
<ul>
 	<li>Returns the least integer greater than or equal to <em>number</em></li>
</ul>
</li>
 	<li>cos (<em>number</em>)
<ul>
 	<li>Returns the cosine of <em>number</em> where <em>number</em> is expressed in radians</li>
</ul>
</li>
 	<li>exp (<em>number</em>)
<ul>
 	<li>Returns <em>e, </em>to the power of <em>number</em> (i.e. <em>e</em><sup><em>number</em></sup>)</li>
</ul>
</li>
 	<li>floor (<em>number</em>)
<ul>
 	<li>Returns the greatest integer less than or equal to its argument</li>
</ul>
</li>
 	<li>log (<em>number)</em>
<ul>
 	<li>Returns the natural logarithm (base <em>e</em>) of <em>number</em></li>
</ul>
</li>
 	<li>max (<em>number1</em>, <em>number2</em>)
<ul>
 	<li>Returns the greater of <em>number1</em> and <em>number2</em></li>
</ul>
</li>
 	<li>min (<em>number1</em>, <em>number2</em>)
<ul>
 	<li>Returns the lesser of <em>number1</em> and <em>number2</em></li>
</ul>
</li>
 	<li>pow (<em>base</em>, <em>exponent</em>)
<ul>
 	<li>Returns <em>base</em> to the <em>exponent</em> power (i.e. <em>base</em><sup><em>exponent</em></sup>)</li>
</ul>
</li>
 	<li>random ()
<ul>
 	<li>Returns a pseudo-random number between zero and one.</li>
</ul>
</li>
 	<li>round (<em>number</em>)
<ul>
 	<li>Returns the value of <em>number</em> rounded to the nearest integer</li>
</ul>
</li>
 	<li>sin (<em>number</em>)
<ul>
 	<li>Returns the sine of <em>number</em> where <em>number</em> is expressed in radians</li>
</ul>
</li>
 	<li>sqrt (<em>number</em>)
<ul>
 	<li>Returns the square root of its argument</li>
</ul>
</li>
 	<li>tan (<em>number</em>)
<ul>
 	<li>Returns the tangent of <em>number</em>, where <em>number</em> is expressed in radians</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>SFColor/SFColorRGBA Object</h1>
The SFColor object corresponds to a X3D SFColor field. All properties are accessed using the syntax <em>sfColorObjectName.&lt;property&gt;</em>, where
<em>sfColorObjectName</em> is an instance of a SFColor object. All methods are invoked using the syntax <em>sfColorObjectName.method (&lt;argument-list&gt;)</em>, where <em>sfColorObjectName</em> is an instance of a SFColor object.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>sfColorObjectName =</em> new SFColor (<em>r, g, b)</em>
<ul>
 	<li><em>r, g, </em>and <em>b</em> are scalar values with the red, green, and blue values of the color</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>r
<ul>
 	<li>red component of the color</li>
</ul>
</li>
 	<li>g
<ul>
 	<li>green component of the color</li>
</ul>
</li>
 	<li>b
<ul>
 	<li>blue component of the color</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>SFImage Object</h1>
The SFImage object corresponds to a X3D SFImage field.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>sfImageObjectName = </em>new SFRotation (<em>width, height, components[, MFInt32 array])</em>
<ul>
 	<li><em>width</em> is the width in pixels of the image.
<em>height</em> is the height in pixels of the image.
<em>components</em> are the number of components of the image (0-4).
<em>array</em> is a MFInt32 array with pixel data.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>width
<ul>
 	<li>Returns the width of the image in pixels</li>
</ul>
</li>
 	<li>height
<ul>
 	<li>Returns the height of the image in pixels</li>
</ul>
</li>
 	<li>comp
<ul>
 	<li>Returns the number of components</li>
</ul>
</li>
 	<li>array
<ul>
 	<li>a MFInt32 array corresponding to the pixels in the image</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>None</li>
</ul>
</div>
</section><section>
<div>
<h1>SFMatrix Object</h1>
The SFMatrix object provides many useful methods for performing manipulations on 4x4 matrices. Each of element of the matrix can be accessed using C-style array dereferencing (i.e., <em>sflMatrixObjectName[0]</em>).
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>x3dMatrixObjectName = </em>new X3DMatrix (<em>f11, f12, f13, f14, f21, f22, f23, f24, f31, f32, f33, f34, f41, f42, f43, f44)</em>
<ul>
 	<li>A new matrix initialized with the values in <em>f11</em> through <em>f44</em> is created and returned.</li>
</ul>
</li>
 	<li><em>x3dMatrixObjectName = </em>new SFMatrix (<em>)</em>
<ul>
 	<li>A new matrix initialized with the identity matrix is created and returned.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>None</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>setTransform (<em>translation</em>, <em>rotation</em>, <em>scaleFactor</em>, <em>scaleOrientation</em>, <em>center</em>)
<ul>
 	<li>Sets the SFMatrix to the passed values. <em>translation</em> is an SFVec3f object, <em>rotation</em> is a SFRotation object, <em>scaleFactor</em> is a SFVec3f object, <em>scaleOrientation</em> is a SFRotation object and <em>center</em> is a SFVec3f object. Any of the rightmost parameters can be omitted. In other words, the method can take from 0 to 5 parameters. For example, you can specify 0 parameters (resulting in a identity matrix), 1 parameter (a translation), 2 parameters (a translation and a rotation), 3 parameters (a translation, rotation and a scaleFactor), etc. Any unspecified parameter is set to its default as specified in the <a href="http://www.web3d.org/technicalinfo/specifications/vrml97/part1/nodesRef.html#Transform"><strong>Transform</strong></a> node section of the X3D specification.</li>
</ul>
</li>
 	<li>getTransform (<em>translation</em>, <em>rotation</em>, <em>scaleFactor</em>)
<ul>
 	<li>Decomposes the SFMatrix and returns the components in the passed <em>translation</em>, <em>rotation</em>, and <em>scaleFactor </em>objects<em>. </em>The types of the parameters are the same as in <strong>setTransform</strong>. Any projection or shear information in the matrix is ignored.</li>
</ul>
</li>
 	<li>inverse ()
<ul>
 	<li>Returns a SFMatrix whose value is the inverse of this object.</li>
</ul>
</li>
 	<li>transpose ()
<ul>
 	<li>Returns a SFMatrix whose value is the transpose of this object.</li>
</ul>
</li>
 	<li>multLeft ()
<ul>
 	<li>Returns a SFMatrix whose value is the object multiplied by the passed matrix on the left.</li>
</ul>
</li>
 	<li>multRight (<em>matrix</em>)
<ul>
 	<li>Returns a SFMatrix whose value is the object multiplied by the passed <em>matrix</em> on the right.</li>
</ul>
</li>
 	<li>multVecMatrix (<em>vec</em>)
<ul>
 	<li>Returns a SFVec3f whose value is the object multiplied by the passed row vector.</li>
</ul>
</li>
 	<li>multMatrixVec (<em>vec</em>)
<ul>
 	<li>Returns a SFVec3f whose value is the object multiplied by the passed column vector.</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>SFNode Object</h1>
The SFNode object corresponds to a X3D SFNode field.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>sfNodeObjectName = </em>new SFNode (<em>x3dsyntax)</em>
<ul>
 	<li><em>x3dsyntax</em> is a ASCII string containing the definition of a X3D node</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
Each node may assign values to its inputOnly fields and obtain the last output values of its outputOnly fields using the <em>sfNodeObjectName.eventName</em> syntax.
<h2>Methods</h2>
<ul>
 	<li>None</li>
</ul>
</div>
</section><section>
<div>
<h1>SFRotation Object</h1>
The SFRotation object corresponds to a X3D SFRotation field.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>sfRotationObjectName = </em>new SFRotation (<em>x, y, z, angle)</em>
<ul>
 	<li><em>x</em>, <em>y</em>, and <em>z</em> are the axis of the rotation.
<em>angle</em> is the angle of the rotation (in radians). All values are scalar.</li>
</ul>
</li>
 	<li><em>sfRotationObjectName</em> = new SFRotation (<em>axis, angle</em>)
<ul>
 	<li><em>axis</em> is a SFVec3f object whose value is the axis of rotation.
<em>angle</em> is the scalar angle of the rotation (in radians)</li>
</ul>
</li>
 	<li><em>sfRotationObjectName</em> = new SFRotation (<em>fromVector, toVector</em>)
<ul>
 	<li><em>fromVector</em> and <em>toVector</em> are SFVec3f valued objects. These vectors are normalized and the rotation value that would rotate from the
<em>fromVector</em> to the <em>toVector</em> is stored in the object.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>x
<ul>
 	<li>Returns the first value of the axis vector</li>
</ul>
</li>
 	<li>y
<ul>
 	<li>Returns the second value of the axis vector</li>
</ul>
</li>
 	<li>z
<ul>
 	<li>Returns the third value of the axis vector</li>
</ul>
</li>
 	<li>angle
<ul>
 	<li>a SFFloat corresponding to the angle of the rotation (in radians)</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>getAxis ()
<ul>
 	<li>Returns the axis of rotation as an SFVec3f object.</li>
</ul>
</li>
 	<li>inverse ()
<ul>
 	<li>Returns a SFRotation object whose value is the inverse of this object's rotation</li>
</ul>
</li>
 	<li>multiply (rotation)
<ul>
 	<li>Returns an SFRotation whose value is the object multiplied by the passed SFRotation.</li>
</ul>
</li>
 	<li>multVec (<em>vec</em>)
<ul>
 	<li>Returns a SFVec3f whose value is the SFVec3f <em>vec</em> multiplied by the matrix corresponding to this object's rotation.</li>
</ul>
</li>
 	<li>setAxis (<em>vec</em>)
<ul>
 	<li>Set the axis of rotation to the vector passed in <em>vec</em>.</li>
</ul>
</li>
 	<li>slerp (<em>destRotation, t</em>)
<ul>
 	<li>Returns a SFRotation whose value is the spherical linear interpolation between this object's rotation and <em>destRotation</em> at value 0 &lt;= <em>t</em> &lt;= 1. For <em>t</em> = 0, the value is this object's rotation. For <em>t</em> = 1, the value is <em>destRotation</em>.</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>String Object</h1>
The String object corresponds to a X3D SFString field.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>stringObjectName = </em>new String (<em>number)</em>
<ul>
 	<li><em>number</em> is any scalar expression</li>
</ul>
</li>
 	<li><em>stringObjectName = </em>new String (<em>string)</em>
<ul>
 	<li><em>string </em>is any UTF-8 string expression</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of characters in the string</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>charAt (<em>index)</em>
<ul>
 	<li>Returns a String containing the character of the string at position <em>index</em> in the string. <em>index</em> is an integer-valued expressio between 0 and length-1, where length is the number of characters in the string</li>
</ul>
</li>
 	<li>indexOf (<em>string</em>, <em>[fromIndex]</em>)
<ul>
 	<li>Returns the index of the first occurrence of <em>string</em> in the object, starting the search from <em>fromIndex</em>. <em>fromIndex</em> must be between 0 and length -1, where length is the number of characters in the string. If <em>fromIndex</em> is not specified, the search will start with character 0.</li>
</ul>
</li>
 	<li>lastIndexOf (<em>string, [fromIndex]</em>)
<ul>
 	<li>Returns the index of the first occurrence of <em>string</em> in the object, starting the search backwards from <em>fromIndex</em>. <em>fromIndex</em> must be between 0 and length -1, where length is the number of characters in the string. If <em>fromIndex</em> is not specified, the search will start with character length - 1.</li>
</ul>
</li>
 	<li>substring (<em>index1, index2</em>)
<ul>
 	<li>Returns a String containing the desired substring. If <em>index1</em> is less than <em>index2</em>, the substring returned starts with the character at <em>index1</em> and ends with the character before <em>index2</em>. If <em>index1</em> is greater than <em>index2</em>, the substring returned starts with the character at <em>index2</em> and ends with the character before <em>index1</em>. If <em>index1</em> equals <em>index2</em>, the empty string is returned. <em>index1</em> and <em>index2</em> are any integer-valued expressions where 0 &lt;= <em>index1, index2 </em>&lt; length, where length is the number of characters in the string</li>
</ul>
</li>
 	<li>toLowerCase ()
<ul>
 	<li>Returns a String with all alphabetic characters of the string converted to lower case.</li>
</ul>
</li>
 	<li>toUpperCase ()
<ul>
 	<li>Returns a String with all alphabetic characters of the string converted to upper case.</li>
</ul>
</li>
</ul>
<h2>Special Operators</h2>
<ul>
 	<li>+ (addition)
<ul>
 	<li>Creates a new string that represents the concatenation of two strings and/or scalar values</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>SFVec2d/SFVec2f Object</h1>
The SFVec2f object corresponds to a X3D SFVec2f field. Each component of the vector can be accessed using the x and y properties or using C-style array dereferencing (i.e. <em>sfVec2fObjectName[0] </em>or <em>sfVec2fObjectName[1]).</em>
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>sfVec2fObjectName = </em>new SFVec2f (<em>number1, number2)</em>
<ul>
 	<li>where <em>number1</em> and <em>number2</em> are scalar expressions</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>x
<ul>
 	<li>Returns the first value of the vector</li>
</ul>
</li>
 	<li>y
<ul>
 	<li>Returns the second value of the vector</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>add (<em>vec</em>)
<ul>
 	<li>Returns an SFVec2f whose value is the passed SFVec2f added, componentwise, to the object.</li>
</ul>
</li>
 	<li>divide (<em>number</em>)
<ul>
 	<li>Returns an SFVec2f whose value is the object divided by the passed numeric value.</li>
</ul>
</li>
 	<li>dot (<em>vec</em>)
<ul>
 	<li>Returns the dot product of this vector and SFVec2f <em>vec</em></li>
</ul>
</li>
 	<li>length ()
<ul>
 	<li>Returns the geometric length of this vector</li>
</ul>
</li>
 	<li>multiply (<em>number</em>)
<ul>
 	<li>Returns an SFVec2f whose value is the object multiplied by the passed numeric value.</li>
</ul>
</li>
 	<li>negate ()
<ul>
 	<li>Returns an SFVec2f whose value is the componentwise negation of the object.</li>
</ul>
</li>
 	<li>normalize ()
<ul>
 	<li>Returns an SFVec2f of object converted to unit length</li>
</ul>
</li>
 	<li>subtract (<em>vec</em>)
<ul>
 	<li>Returns an SFVec2f whose value is the passed SFVec2f subtracted, componentwise, from the object.</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>SFVec3d/SFVec3f Object</h1>
The SFVec3f object corresponds to a X3D SFVec3f field. Each component of the vector can be accessed using the x, y, and z properties or using C-style array dereferencing (i.e. <em>sfVec3fObjectName[0], sfVec3fObjectName[1] </em>or <em>sfVec3fObjectName[2]).</em>
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>sfVec3fObjectName = </em>new SFVec3f (<em>number1, number2, number3)</em>
<ul>
 	<li>where <em>number1,</em><em>number2, </em>and <em>number3</em> are scalar expressions</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>x
<ul>
 	<li>Returns the first value of the vector</li>
</ul>
</li>
 	<li>y
<ul>
 	<li>Returns the second value of the vector</li>
</ul>
</li>
 	<li>z
<ul>
 	<li>Returns the third value of the vector</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>add (<em>vec</em>)
<ul>
 	<li>Returns an SFVec3f whose value is the passed SFVec3f added, componentwise, to the object.</li>
</ul>
</li>
 	<li>cross (<em>vec</em>)
<ul>
 	<li>Returns the cross product of the object and the passed SFVec3f.</li>
</ul>
</li>
 	<li>divide (<em>number</em>)
<ul>
 	<li>Returns an SFVec3f whose value is the object divided by the passed numeric value.</li>
</ul>
</li>
 	<li>dot (<em>vec</em>)
<ul>
 	<li>Returns the dot product of this vector and SFVec3f <em>vec</em></li>
</ul>
</li>
 	<li>length ()
<ul>
 	<li>Returns the geometric length of this vector</li>
</ul>
</li>
 	<li>multiply (<em>number</em>)
<ul>
 	<li>Returns an SFVec3f whose value is the object multiplied by the passed numeric value.</li>
</ul>
</li>
 	<li>negate ()
<ul>
 	<li>Returns an SFVec3f whose value is the componentwise negation of the object.</li>
</ul>
</li>
 	<li>normalize ()
<ul>
 	<li>Returns an SFVec3f of object converted to unit length</li>
</ul>
</li>
 	<li>subtract (<em>vec</em>)
<ul>
 	<li>Returns an SFVec3f whose value is the passed SFVec3f subtracted, componentwise, from the object.</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>SFVec4d/SFVec4f Object</h1>
The SFVec4f object corresponds to a X3D SFVec4f field. Each component of the vector can be accessed using the x and y properties or using C-style array dereferencing (i.e. <em>sfVec4fObjectName[0] </em>or <em>sfVec4fObjectName[1]).</em>
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>sfVec4fObjectName = </em>new SFVec4f (<em>number1, number2)</em>
<ul>
 	<li>where <em>number1</em> and <em>number2</em> are scalar expressions</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>x
<ul>
 	<li>Returns the first value of the vector</li>
</ul>
</li>
 	<li>y
<ul>
 	<li>Returns the second value of the vector</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
<ul>
 	<li>add (<em>vec</em>)
<ul>
 	<li>Returns an SFVec4f whose value is the passed SFVec4f added, componentwise, to the object.</li>
</ul>
</li>
 	<li>divide (<em>number</em>)
<ul>
 	<li>Returns an SFVec4f whose value is the object divided by the passed numeric value.</li>
</ul>
</li>
 	<li>dot (<em>vec</em>)
<ul>
 	<li>Returns the dot product of this vector and SFVec4f <em>vec</em></li>
</ul>
</li>
 	<li>length ()
<ul>
 	<li>Returns the geometric length of this vector</li>
</ul>
</li>
 	<li>multiply (<em>number</em>)
<ul>
 	<li>Returns an SFVec4f whose value is the object multiplied by the passed numeric value.</li>
</ul>
</li>
 	<li>negate ()
<ul>
 	<li>Returns an SFVec4f whose value is the componentwise negation of the object.</li>
</ul>
</li>
 	<li>normalize ()
<ul>
 	<li>Returns an SFVec4f of object converted to unit length</li>
</ul>
</li>
 	<li>subtract (<em>vec</em>)
<ul>
 	<li>Returns an SFVec4f whose value is the passed SFVec4f subtracted, componentwise, from the object.</li>
</ul>
</li>
</ul>
</div>
</section><section>
<div>
<h1>MFBool Object</h1>
The MFBool object corresponds to a X3D MFBool field. It is used to store a one-dimensional array of SFBool objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfBoolObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to 0.0.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfBoolObjectName = </em>new MFBool (<em>[boolean, boolean...])</em>
<ul>
 	<li>The creation method can be passed 0 or more numeric-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFColor/MFColorRGBA Object</h1>
The MFColor object corresponds to a X3D MFColor field. It is used to store a one-dimensional array of SFColor objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfColorObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em> length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to SFColor (0, 0, 0).
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfColorObjectName = </em>new MFColor (<em>[SFColor, SFColor, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more SFColor-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFDouble/MFFloat Object</h1>
The MFFloat object corresponds to a X3D MFFloat field. It is used to store a one-dimensional array of SFFloat objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfFloatObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to 0.0.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfFloatObjectName = </em>new MFFloat (<em>[number, number...])</em>
<ul>
 	<li>The creation method can be passed 0 or more numeric-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFImage Object</h1>
The MFImage object corresponds to a X3D MFImage field. It is used to store a one-dimensional array of SFImage objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfImageObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to SFImage (0,0,0).
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfImageObjectName = </em>new MFImage<em>[SFImage, SFImage, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more SFImage-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFInt32 Object</h1>
The MFInt32 object corresponds to a X3D MFInt32 field. It is used to store a one-dimensional array of SFInt32 objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfInt32ObjectName</em>[<em>index]</em>, where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to 0.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfInt32ObjectName = </em>new MFInt32 (<em>[number, number, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more integer-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFNode Object</h1>
The MFNode object corresponds to a X3D MFNode field. It is used to store a one-dimensional array of SFNode objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfNodeObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to NULL.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfNodeObjectName = </em>new MFNode (<em>[SFNode, SFNode, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more SFNode-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFRotation Object</h1>
The MFRotation object corresponds to a X3D MFRotation field. It is used to store a one-dimensional array of SFRotation objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfRotationObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to SFRotation (0, 0, 1, 0).
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfRotationObjectName = </em>new MFRotation (<em>[SFRotation, SFRotation, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more SFRotation-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFString Object</h1>
The MFString object corresponds to a X3D MFString field. It is used to store a one-dimensional array of String objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfStringObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to the empty string.
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfStringObjectName = </em>new MFString<em>[string, string, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more string-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFVec2d/MFVec2f Object</h1>
The MFVec2f object corresponds to a X3D MFVec2f field. It is used to store a one-dimensional array of SFVec2f objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfVec2fObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to SFVec2f (0, 0).
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfVec2fObjectName = </em>new MFVec2f (<em>[SFVec2f, SFVec2f, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more SFVec2f-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFVec3d/MFVec3f Object</h1>
The MFVec3f object corresponds to a X3D MFVec3f field. It is used to store a one-dimensional array of SFVec3f objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfVec3fObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to SFVec3f (0, 0, 0).
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfVec3fObjectName = </em>new MFVec3f (<em>[SFVec3f, SFVec3f, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more SFVec3f-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section><section>
<div>
<h1>MFVec4d/MFVec4f Object</h1>
The MFVec4f object corresponds to a X3D MFVec4f field. It is used to store a one-dimensional array of SFVec4f objects. Individual elements of the array can be referenced using the standard C-style dereferencing operator (e.g. <em>mfVec4fObjectName</em>[<em>index</em>], where <em>index</em> is an integer-valued expression with 0&lt;=<em>index</em>&lt;length and length is the number of elements in the array). Assigning to an element with <em>index</em> &gt; length results in the array being dynamically expanded to contain length elements. All elements not explicitly initialized are set to SFVec4f (0, 0).
<h2>Instance Creation Method(s)</h2>
<ul>
 	<li><em>mfVec4fObjectName = </em>new MFVec4f (<em>[SFVec4f, SFVec4f, ...])</em>
<ul>
 	<li>The creation method can be passed 0 or more SFVec4f-valued expressions to initialize the elements of the array.</li>
</ul>
</li>
</ul>
<h2>Properties</h2>
<ul>
 	<li>length
<ul>
 	<li>An integer containing the number of elements in the array. Assigning an integer to length changes the number of elements in the array.</li>
</ul>
</li>
</ul>
<h2>Methods</h2>
None

</div>
</section>